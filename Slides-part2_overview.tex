%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\talksection{Overview}

\begin{frame}{Structure}

\begin{itemize}
    \item Pipeline design
    \begin{itemize}
        \item $F$ is repeatedly transformed by different stages
        \item Stages are independent from each other
        \item Each stage consists of one or more IR passes
        \item Most stages require some analysis
    \end{itemize}
    \item Analyses
    \begin{itemize}
        \item Capture information about the IR to vectorize
        \item May need updating after a stage (stale information)
        \item May depend on other analyses
    \end{itemize}
\end{itemize}

\center{\includegraphics[width=0.8\textwidth]{images/stages.pdf}}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Analysis Examples}

\begin{itemize}
    \item Uniform Value Analysis
    \begin{itemize}
        \item Marks values as either \uniform{uniform} or \varying{varying}
    \end{itemize}

    \item Control Flow Analysis
    \begin{itemize}
        \item Determines which basic blocks are \varying{divergent}
        \item Builds a Control Dependency Graph
    \end{itemize}
    
    \item SIMD Width Analysis
    \begin{itemize}
        \item Chooses a 'good' width $N$ based on register/instruction usage
    \end{itemize}
    
    \item ...
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Implementation Level: IR or MI?}

\begin{itemize}
    \item IR Level
    \begin{itemize}
        \item \pointfor{Use-def graph and \texttt{RAUW} make for straightforward transformations}
        \item \pointfor{Easy to target multiple platforms}
        \item \pointunkn{Generally higher-level (simpler implementation?)}
        \item \pointagainst{Platform-specific features more difficult to use}
        \item \pointagainst{Predication only for select operations (select, load/stores)}
    \end{itemize}

    \item MachineInstr level
    \begin{itemize}
        \item \pointfor{Easy to use platform-specific features (e.g. predication, mask registers)}
        \item \pointunkn{Generally lower-level (more powerful?)}
        \item \pointagainst{More platform-specific code}
        \item \pointagainst{Graph-based transformations not as straightforward}
    \end{itemize}
    
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\begin{frame}{Implementation strategy}
%
%% TODO: Skip slide?
%\begin{itemize}
%    \item Create test kernels
%    \begin{itemize}
%        \item Start with very simple kernels (e.g. copy buffer, add two buffers)
%        \item Gradually add more features (e.g. non-sequential memory accesses, vector instructions, etc)
%    \end{itemize}
%
%    
%    \item Suggested implementation order
%    \begin{itemize}
%        \item Preparation and packetization first (required for simplest kernels)
%        \item Then easier features: builtins, memory addressing, scalarization, instantiation
%        \item More complex features last: control flow, optimizations
%    \end{itemize}
%\end{itemize}
%
%\end{frame}
