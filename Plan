Part * Introduction (4 min, 3 slides) goal 3 min

Part 1 Background (8 min, 8 slides) goal 8 min
    Execution Model (? min, 3 slides)
    Vectorization (? min, 5 slides)

Part 2 Implementing a basic vectorizer (25 min) goal 32 min
    Overview (? min, 3 slides) goal 4 min
    Packetization stage (? min, 18 slides) goal 15 min (2nd run 9 min)
    Scalarization stage (? min, 2 slides) goal 3 min (2nd run 2 min)
    Control flow stage (? min, 10+? slides) goal 10 min (2nd run 15 min)
    
Part 3 Going further (? min) goal 5 min

Part * Conclusion (3 min) goal 2 min (2nd run 2 min)


Chalkboard themed diagrams
    ./replace_svg_colour.sh 00ffff bcdf8a # cyan -> light green
    ./replace_svg_colour.sh ff99ff 94c0cc # pink -> blue

TODO
    Part 3 ideas
        SIMD width detection
            Basic process
                Visit varying nodes
                Record widest type
                N = largest vector register / widest type
            Use register pressure
                Max usage < 1/p ? Multiply N by p
            Use a cost model
        CFG Specialization
            Duplicate part of the CFG
                e.g. assuming all lanes enabled
                Avoids CFG conversion and predication for the specialized part
                Increases code size
            Need to generate an extra branch (guard) to specialized code
                e.g. 'b i1 (all m_{A->B}), %B_{spec}, %B'
                
            loop in if example
        CFG Conversion: Special Case
            Branch always taken by a single lane
                'if (tid == 0) { /* write back result */ }' example 
                Often used with reductions
            No need for CFG conversion
                Keep the conditional branch
            No need for packetization
