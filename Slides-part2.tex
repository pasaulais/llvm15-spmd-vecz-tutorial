%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\talksection{Design}

\begin{frame}{Design}

\begin{itemize}
    \item Pipeline structure
    \begin{itemize}
        \item Function to vectorize is repeatedly transformed by different stages
        \item Each stage consists of one or more IR passes
        \item Most stages require some analysis
        \begin{itemize}
            \item May be run mulitple times as stages invalidate it
        \end{itemize}
    \end{itemize}
    
    \item The LLVM pass manager (both new and original) is a good fit here
    \begin{itemize}
        \item Most passes work at the function level
        \item Access to the module is sometimes needed
    \end{itemize}
    
    \item The original function can be preserved or not
    \begin{itemize}
        \item In-place: vectorize the original function, no need for cloning
        \item Work on cloned function: allow vectorization to fail
    \end{itemize}
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Stages}

% Stage diagram with stages: preparation, CFG conversion, scalarization, packetization, optimizations

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Analyses}

% Two important anlyses: UVA and CFG

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Implementation strategy}

\begin{itemize}
    \item Create test kernels
    \begin{itemize}
        \item Start with very simple kernels (e.g. copy buffer, add two buffers)
        \item Gradually add more features (e.g. non-sequential memory accesses, vector instructions, etc)
        \item
    \end{itemize}

    
    \item Suggested implementation order
    \begin{itemize}
        \item Preparation and packetization first (required for simplest kernels)
        \item Then easier features: builtins, memory addressing, scalarization, instantiation
        \item More complex features last: control flow, optimizations
    \end{itemize}
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\talksection{Stage: Packetization}

\begin{frame}{Packetization Overview}

\begin{itemize}
    \item Stage that does the actual vectorization
    \begin{itemize}
        \item Needs a vectorization factor $N$ (SIMD width)
        \item Calling the transformed function is like calling the original $N$ times
        \item Straightforward thanks to preparation from previous stages
    \end{itemize}
    
    \item This is done per-instruction, for the whole function
    \begin{itemize}
        \item Instructions that define a value: define $N$ values, one for each instance
        \item Instructions with side effects: perform side effects for each instance
    \end{itemize}
    
    \item Only varying instructions need packetization
    \begin{itemize}
        \item Uniform instructions can remain scalar, executed once per work-group
        \item Requires \textbf{Uniform Value Analysis} to know which instructions to vectorize
    \end{itemize}
    
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Uniform Value Analysis}

\begin{itemize}
    \item Finds 'root' values
    \begin{itemize}
        \item Varying value that doesn't have any varying operand
        \item Example: \texttt{get\_global\_id(0)} has a different value for each isntance
    \end{itemize}
    \item Marks each IR value as 'uniform' or 'varying'
    \begin{itemize}
        \item All values start as 'uniform'
        \item Marking a value as 'varying' causes all users to also be marked 'varying'
        \item Marking is done recursively, starting with roots
        \item Values are marked before their users, to avoid cycles (phi nodes)
    \end{itemize}
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Uniform Value Analysis Example}

Example that combines uniform and varying values:

\begin{codebox}[commandchars=\\\[\]]
kernel void add_uniform(global int *\codeemphb[dst], global int *\codeemphb[src], int \codeemphb[alpha]) {
    int \codeempha[tid] = \codeempha[get_global_id](0);
    \codeemphb[dst]\idx[\codeempha[tid]] = \codeemphb[src]\idx[\codeempha[tid]] + (\codeemphb[alpha] + \codeemphb[1]);
}
\end{codebox}

\begin{codebox}[commandchars=\\\[\]]
define void @add_uniform(i32 addrspace(1)* \codeemphb[%dst], i32 addrspace(1)* \codeemphb[%src],
                         i32 \codeemphb[%alpha]) {
entry:
  \codeempha[%tid] = i32 \codeempha[@get_global_id(i32 0)]
  \codeempha[%arrayidx] = getelementptr inbounds i32 addrspace(1)* \codeemphb[%src], i32 \codeempha[%tid]
  \codeempha[%tmp] = load i32 addrspace(1)* \codeempha[%arrayidx], align 4
  \codeemphb[%add] = add nsw i32 \codeemphb[%alpha], \codeemphb[1]
  \codeempha[%add1] = add nsw i32 \codeemphb[%add], \codeempha[%tmp]
  \codeempha[%arrayidx2] = getelementptr inbounds i32 addrspace(1)* \codeemphb[%dst], i32 \codeempha[%tid]
  store i32 \codeempha[%add1], i32 addrspace(1)* \codeempha[%arrayidx2], align 4
  ret void
}
\end{codebox}

% Mix of uniform and varying values
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Uniform Value Analysis Example}

% IR graph to show values, highlight uniform and varying ones

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Packetization Process}

\begin{itemize}
    \item Start at leaves
    \item Packetize operands before instructions
    \item Broadcast uniform operands
    \item Cache packetized values to prevent duplication
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Packetization Example}

\begin{itemize}
    \item How does it work?
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Packetization: Phi nodes}

\begin{itemize}
    \item How to handle this special case
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Memory addressing}

\begin{itemize}
    \item Uniform address -> scalar loads and stores
    \item Constant stride =1 -> vector laods and stores
    \item Constant stride >1 -> interleaved loads and stores
    \item Other -> gather loads, scatter stores
\end{itemize}

% Generate calls to internal builtins
% Internal builtins can be implemented for each target as supported

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\talksection{Stage: Scalarization}

\begin{frame}{Scalarization Overview}

\begin{itemize}
    \item What does it do?
    \item Requires scalarization analysis
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Scalarization Analysis}

\begin{itemize}
    \item Looks for vector instructions
    \begin{itemize}
        \item Leaves that define vector values, vector stores
        \item Vector extractions
        \item Vector -> scalar bitcasts
    \end{itemize}
    
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Scalarization Process}


\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Scalarization Example}


\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\talksection{Stage: Control Flow Conversion}

\begin{frame}{Control Flow Conversion Overview}

\begin{itemize}
    \item What does it do?
    \item Why is it needed?
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Control Flow Conversion: if}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Mask Generation}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Applying Masks}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Masked Memory Operations}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Phi Conversion}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{CFG Linearization}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Control Flow Conversion: loops}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Finding Loop Live Variables}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Merging Loop Live Variables}

\end{frame}
