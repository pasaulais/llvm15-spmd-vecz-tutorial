%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\talksection{Design}

\begin{frame}{Design}

\begin{itemize}
    \item Pipeline structure
    \begin{itemize}
        \item Function to vectorize is repeatedly transformed by different stages
        \item Each stage consists of one or more IR passes
        \item Most stages require some analysis
        \begin{itemize}
            \item May be run mulitple times as stages invalidate it
        \end{itemize}
    \end{itemize}
    
    \item The LLVM pass manager (both new and original) is a good fit here
    \begin{itemize}
        \item Most passes work at the function level
        \item Access to the module is sometimes needed
    \end{itemize}
    
    \item The original function can be preserved or not
    \begin{itemize}
        \item In-place: vectorize the original function, no need for cloning
        \item Work on cloned function: allow vectorization to fail
    \end{itemize}
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Stages}

% Stage diagram with stages: preparation, CFG conversion, scalarization, packetization, optimizations

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Analyses}

% Two important anlyses: UVA and CFG

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Implementation strategy}

\begin{itemize}
    \item Create test kernels
    \begin{itemize}
        \item Start with very simple kernels (e.g. copy buffer, add two buffers)
        \item Gradually add more features (e.g. non-sequential memory accesses, vector instructions, etc)
        \item
    \end{itemize}

    
    \item Suggested implementation order
    \begin{itemize}
        \item Preparation and packetization first (required for simplest kernels)
        \item Then easier features: builtins, memory addressing, scalarization, instantiation
        \item More complex features last: control flow, optimizations
    \end{itemize}
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\talksection{Stage: Packetization}

\begin{frame}{Packetization Overview}

\begin{itemize}
    \item Stage that does the actual vectorization
    \begin{itemize}
        \item Needs a vectorization factor $N$ (SIMD width)
        \item Calling the transformed function is like calling the original $N$ times
        \item Straightforward thanks to preparation from previous stages
    \end{itemize}
    
    \item This is done per-instruction, for the whole function
    \begin{itemize}
        \item Instructions that define a value: define $N$ values, one for each instance
        \item Instructions with side effects: perform side effects for each instance
    \end{itemize}
    
    \item Only varying instructions need packetization
    \begin{itemize}
        \item Uniform instructions can remain scalar, executed once per work-group
        \item Requires \textbf{Uniform Value Analysis} to know which instructions to vectorize
    \end{itemize}
    
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Uniform Value Analysis}

\begin{itemize}
    \item Finds 'root' values
    \begin{itemize}
        \item \varying{Varying} value that doesn't have any \varying{varying} operand
        \item Example: \varying{get\_global\_id(0)} has a different value for each isntance
    \end{itemize}
    \item Marks each IR value as \uniform{uniform} or \varying{varying}
    \begin{itemize}
        \item All values start as \uniform{uniform}
        \item Marking a value as \varying{varying} causes all users to also be marked \varying{varying}
        \item Marking is done recursively, starting with roots
        \item Values are marked before their users, to avoid cycles (phi nodes)
    \end{itemize}
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Uniform Value Analysis}

Example that combines \uniform{uniform} and \varying{varying} values:

\begin{codebox}[commandchars=\\\[\]]
kernel void add_uniform(global int *\uniform[dst], global int *\uniform[src], int \uniform[alpha]) {
    int \varying[tid] = \varying[get_global_id](0);
    \uniform[dst]\idx[\varying[tid]] = \uniform[src]\idx[\varying[tid]] + (\uniform[alpha] + \uniform[1]);
}
\end{codebox}

\begin{codebox}[commandchars=\\\[\]]
define void @add_uniform(i32 addrspace(1)* \uniform[%dst], i32 addrspace(1)* \uniform[%src],
                         i32 \uniform[%alpha]) {
entry:
  \varying[%tid] = i32 \varying[@get_global_id(i32 0)]
  \varying[%arrayidx] = getelementptr inbounds i32 addrspace(1)* \uniform[%src], i32 \varying[%tid]
  \varying[%tmp] = load i32 addrspace(1)* \varying[%arrayidx], align 4
  \uniform[%add] = add nsw i32 \uniform[%alpha], \uniform[1]
  \varying[%add1] = add nsw i32 \uniform[%add], \varying[%tmp]
  \varying[%arrayidx2] = getelementptr inbounds i32 addrspace(1)* \uniform[%dst], i32 \varying[%tid]
  store i32 \varying[%add1], i32 addrspace(1)* \varying[%arrayidx2], align 4
  ret void
}
\end{codebox}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Uniform Value Analysis}

TBD: IR graph to show values, highlight \uniform{uniform} and \varying{varying} nodes

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Packetization Process}

\begin{itemize}
    \item Find leaves
    \begin{itemize}
        \item Leaves allow \varying{varying} values to 'escape' from the function, they are:
        \item Store instructions (\varying{varying} operand)
        \item Call instructions (\varying{varying} operand, or call has no use)
        \item Return instructions
    \end{itemize}
\end{itemize}

\begin{itemize}
    \item Recursively packetize leaves and their operands
    \begin{itemize}
        \item Broadcast \uniform{uniform} operands (e.g. argument, constants)
        \item Replace \varying{get\_global\_id(0)} with a vector of IDs
        \item Packetize operands first, then instruction
        \item Cache packetized values to prevent duplication
    \end{itemize}
\end{itemize}

\begin{itemize}
    \item Delete original scalar instructions if dead
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Packetization Example}

\begin{itemize}
    \item How does it work?
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]{Packetizing Phi nodes}

\begin{itemize}
    \item Phi nodes can introduce cycles in the use/def graph
    \begin{itemize}
        \item Phi operands that reference the same phi
        \item Example: reduction variables
    \end{itemize}
    \item Break the cycle by creating 'empty' phi nodes
    \item Packetize operands of phi nodes after leaves have been packetized
\end{itemize}

\begin{itemize}
    \item TODO: graph
\end{itemize}  

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Memory addressing}

\begin{itemize}
    \item Uniform address -> scalar loads and stores
    \item Constant stride =1 -> vector laods and stores
    \item Constant stride >1 -> interleaved loads and stores
    \item Other -> gather loads, scatter stores
\end{itemize}

% Generate calls to internal builtins
% Internal builtins can be implemented for each target as supported

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\talksection{Stage: Scalarization}

\begin{frame}{Scalarization Overview}

\begin{itemize}
    \item What does it do?
    \item Requires scalarization analysis
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Scalarization Analysis}

\begin{itemize}
    \item Looks for vector instructions
    \begin{itemize}
        \item Leaves that define vector values, vector stores
        \item Vector extractions
        \item Vector -> scalar bitcasts
    \end{itemize}
    
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Scalarization Process}


\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Scalarization Example}


\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\talksection{Stage: Control Flow Conversion}

\begin{frame}{Control Flow Conversion Overview}

\begin{itemize}
    \item What does it do?
    \item Why is it needed?
\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Control Flow Conversion: if}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Mask Generation}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Applying Masks}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Masked Memory Operations}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Phi Conversion}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{CFG Linearization}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Control Flow Conversion: loops}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Finding Loop Live Variables}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{Merging Loop Live Variables}

\end{frame}
